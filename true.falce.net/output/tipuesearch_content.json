{"pages":[{"url":"http://true.falce.net/a-la-decouverte-de-netcat.html","text":"Aujourd'hui faisons la découverte du merveilleux outils netcat ou le couteau suisse du développement web . Cet application est très pratique quand on fait de la programmation réseau, pour déboguer, mais aussi pour les admins sys. Par exemple, a chaque fois que j'ai fait de la prog réseau, tout était fragile : un socket qui n'écoute qu'en local, un parefeu capricieux, une interface réseau qui fait n'importe quoi et plus rien ne marche sans savoir d'où ça peut venir. Et le débug n'est pas évident en réseau, c'est là que l'on est content d'avoir netcat . Installation netcat n'est pas installé par défaut sur certains linux. Il existe 2 versions, qui malheureusement n'acceptent pas les même options : netcat-openbsd et netcat-traditional . Vous pouvez savoir lequel est installé en faisant netcat Et la réponse devrait être quelque chose du genre (ubuntu 14.04): This is nc from the netcat-openbsd package. An alternative nc is available in the netcat-traditional package. usage: nc [ -46bCDdhjklnrStUuvZz ] [ -I length ] [ -i interval ] [ -O length ] [ -P proxy_username ] [ -p source_port ] [ -q seconds ] [ -s source ] [ -T toskeyword ] [ -V rtable ] [ -w timeout ] [ -X proxy_protocol ] [ -x proxy_address [ :port ]] [ destination ] [ port ] Dans ce cas, on a… la version openbsd. Pour passer d'une version à une autre, il suffit de faire : apt-get remove netcat-traditional apt-get install netcat-openbsd Dans ce tutoriel, nous utiliserons netcat-openbsd . Et pour windows ? Il existe une version windows, je vous laisse la trouver :p Utilisation basique On va faire un petit tchat en ligne de commandes. En 2 lignes. La classe quoi. En réseau il s'agit souvent d'une communication entre en serveur et un client. Comme au restaurant, le serveur écoute le client qui lui demande des choses et un serveur peu servir plusieurs clients (mais en se concentrant sur un seul à la fois). Par défaut netcat effectue ses connexions en TCP , mais il est possible de les passer en UDP en rajoutant l'option -u . Serveur netcat -l 9876 Crée un serveur (l'option -l ) qui écoute sur le port 9876 Client netcat localhost 9876 Crée un client qui se connecte à localhost sur le port 9876. Tchat Pour faire un tchat, il suffit d'ouvrir 2 terminaux, de créer un serveur et un client. Les commandes ne devraient pas rendre la main et vous pouvez taper du texte, appuyer sur entrée et le voir s'afficher sur l'autre terminal. Pour terminer, appuyez sur Ctrl-C , fermer le client ou le serveur va déconnecter l'autre automatiquement. N'oubliez pas, il faut lancer le serveur en premier puis créer un client. Essayez maintenant de lancer un autre client, il ne peut pas se connecter. netcat ne permet pas d'avoir de connections concurrentes, si vous en avez besoin, il faut utiliser d'autres outils. Remarque Vu que les communications passent par TCP ou UDP , on n'est pas obligé d'utiliser netcat de chaque côté, il suffit d'utiliser une connexion socket. Vous pouvez donc déboguer vos codes Python ou C ou n'importe quoi avec des sockets en utilisant le tchat. C'est très pratique pour savoir s'il y a des problèmes au niveau de caractères (rajoutés ou supprimés) ou bien si des connexions se ferment alors qu'elles ne devraient pas. Application : savoir si vous êtes bloqués par un parefeu On peut utiliser ce tchat pour savoir si un parefeu vous bloque ou s'il y a un problème quelconque au niveau de la connexion. Pour rappel, les pare-feu peuvent être sortant ou entrant, et un port qui laisse passer dans un sens et pas dans l'autre peut être assez long à déboguer. Voilà comment faire : vous avez un ordinateur accessible par une IP sur internet, on va l'appeler S et un ordinateur qui veux y accéder, que l'on va appeler A. vous pingez S depuis A. Si ça ne marche pas il y a un problème de connexion. vous lancez un serveur netcat sur S sur le port d'intérêt. vous lancez un client sur A vers l' IP de S avec le bon port. Si le client n'arrive pas à se connecter c'est que le port est bloqué en entré, sinon c'est bon vous essayez d'écrire depuis S sur A si ça marche, il n'y a pas de pare-feu sortant. Bon après, on peut faire un nmap aussi, mais je ne me souviens jamais de la ligne de commande à faire… Utilisation plus avancée Tester des pare-feu, c'est sympa, mais on peu faire plus. Débug de serveur web Si vous utilisez un serveur web avec un proxy inverse ou des réécritures d' URL , vous pouvez avoir envie de tester s'il est réglé correctement, au niveau des URL ou des header HTTP par exemple. Il suffit de faire un serveur en netcat et de se connecter sur l' URL ou le port avec un navigateur pour voir les header HTTP . Voilà un exemple avec firefox sur un Ubuntu (connexion sur localhost:8855) : ➭ nc -l 8855 GET / HTTP / 1 .1 Host : localhost :8855 User-Agent : Mozilla / 5 .0 ( X11 ; Ubuntu ; Linux x86_64 ; rv :40 .0 ) Gecko / 20100101 Firefox / 40 .0 Accept : text / html , application / xhtml + xml , application / xml ; q = 0 .9 ,*/*; q = 0 .8 Accept-Language : en-US , en ; q = 0 .5 Accept-Encoding : gzip , deflate Connection : keep-alive Exemple d'une connexion sur localhost:8855/une-autre- URL ➭ nc -l 8855 GET / une-autre-URL HTTP / 1 .1 Host : localhost :8855 User-Agent : Mozilla / 5 .0 ( X11 ; Ubuntu ; Linux x86_64 ; rv :40 .0 ) Gecko / 20100101 Firefox / 40 .0 Accept : text / html , application / xhtml + xml , application / xml ; q = 0 .9 ,*/*; q = 0 .8 Accept-Language : en-US , en ; q = 0 .5 Accept-Encoding : gzip , deflate Connection : keep-alive Comme netcat se ferme à chaque connexion, on peut utiliser la commande suivante pour la rouvrir automatiquement : while true ; do nc -l PORT ; done Partager des fichiers netcat permettant d'ouvrir des communications réseau et de faire passer du texte, on peut aussi faire passer des fichiers d'un ordinateur à un autre : sur le serveur : cat backup.iso | nc -l 3333 sur le client : nc IP_SERVEUR 3333 > backup.iso Le seul problème c'est que l'on ne peut pas savoir où en est le téléchargement. Dans ce cas, on peut faire : sur le serveur : pv backup.iso | nc -l 3333 sur le client : nc IP_SERVEUR 3333 |pv > backup.iso Avec pv qui est l'utilitaire pipe view (à installer) qui permet d'afficher des barres de progressions. SSH hopping Imaginons le cas suivant pour une connexion SSH : vous avez un serveur publique : GW , accessible par internet, qui sert de porte d'entrée sur votre réseau privé, un Gateway vous avez un serveur sur un réseau privé : SPr , qui ne sont pas accessible par internet, mais GW peut y accéder Si vous voulez vous connecter à SPr par ssh , vous devez faire une connexion à GW puis une autre à SPr . C'est long et ça peut amener à faire des erreurs. Il faudrait une façon automatique de sauter de GW à Spr , de faire un ‘hop' entre les deux (d'où le nom de la technique) . Dans ce cas, vous pouvez utiliser netcat dans votre ~/.ssh/config : Host GW HostName GW.example.com Host SPr ProxyCommand ssh -q GW nc -q0 SPr 22 Le proxycommand signifie que ssh SPr va en fait exécuter ssh -q GW nc -q0 SPr 22 . Donc execute une connexion ssh classique sur GW puis une fois connecté, fait un nc sur le port 22 du SPr . Comme le port 22 est le port classique pour ssh , tout ce qui passe dans le premier ssh sera transmit à la 2ème machine. Bonus Un outil de supervision Vous utilisez Munin ou un truc dans le genre pour savoir les ressources utilisées par vos serveurs ou les processus qui tournent ? Laissez tomber et utilisez netcat ! On peut afficher le résultat d'un top dans une page web : ( trap \"exit\" INT ; while true ; do top -b -n1 | nc -l 8855 ; done ) top -b -n1 permet d'avoir une sortie récupérable (et non pas interactive) pour top . Le trap \"exit\" INT permet de quitter le programme, sinon il ignore les interruptions avec Ctrl-C . NGINX c'est surfait, utilisons nc :) On peut servir une page statique avec netcat pour remplacer vite fait un serveur web en rade. Bon, ça sert juste du HTML , sans autres ressources et ça sert la même chose sur toutes les URL mais ça dépanne : On peut tester quelque chose comme ça : while true ; do nc -l 80 < index.html ; done Cependant, le navigateur affiche le texte sans faire le rendu HTML . netcat ne respectant pas HTTP de base, il faut rajouter un header HTTP minimum : \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n\" ( trap \"exit\" INT ; while true ; do { echo \"HTTP/1.1 200 OK\\r\\nContent-Type: text/html\\r\\n\\r\\n\" ; cat index.html } | nc -l 8855 ; done ) Pour aller plus loin : vous pouvez installer netcat-traditional et jouer avec les options -e et -c on peut utiliser netcat comme scanner de ports on peut crypter les communications en passant la connexion dans un SSH ou en utilisant d'autres outils Avec des FIFO , on peut faire un \"man-in-the-middle\" pour avoir tous les logs navigateur et serveur dans un fichier tout en continuant à servir le site normalements allez, faites un skype du pauvre avec netcat ! Sources Lien SO expliquant comment passer d'une version traditionelle à une version bsd. Lien askubuntu sur le ssh hopping Plus d'infos sur le multi hop Quelques utilisations de netcat, j'en ai repris la plupart Capture de top Inspiration pour le serveur web en nc Cool stuff to do with netcat sur HN Inspiration pour le serveur web qui fonctionne, proxy TCP J'espère avoir pu vous faire partager la puissance de cet outil. Il ne vous reste plus qu'à utiliser nc pour vos débugs réseau et autres geekeries ;) Si vous avez d'autres techniques, n'hésitez pas à les partager en commentaire.","tags":"Admin Sys","title":"A la découverte de netcat"},{"url":"http://true.falce.net/comment-avoir-plusieurs-services-web-sur-son-serveur.html","text":"C'est le genre de questions bêtes que l'on se pose quand on débute. Les tutoriels parlent de configuration de serveurs et on ne comprend pas l'intérêt réel. La philosophie de l'article est plus de découvrir le principe que de fournir une solution clef en main :) Le problème J'ai un serveur web (un ordinateur), sur lequel tourne un serveur web (un logiciel, NGINX ) qui sert mon site web, sur le port 80 donc. Maintenant imaginons que je veuille développer une application web, en Python/Flask par exemple. L'application va écouter sur un certain port, disons 12345 . Je peux y accéder en faisant http://monip:12345 . Bon jusque là rien de nouveau sous le soleil. Mais ce n'est pas très sérieux : ça fait peut aux gens d'accéder à un port précis, ils n'ont pas l'habitude et ne se connecterons pas c'est plus simple de se souvenir d'un nom que d'un chiffre aléatoire Une meilleure solution c'est d'accéder à http://monip/monapp ou http://monapp.monip plutôt que sur un port. Sauf que le serveur web est déjà attaché au port 80 et qu'un seul processus peut se connecter sur un port. La solution Pré-requis Je pars du principe que vous utilisez un Linux et avez installé un serveur web ( NGINX ou Apache) qui fonctionne. Même si vous n'avez encore rien configuré parce que vous ne pigez rien aux tutos. Les examples se baseront sur NGINX . Un proxy inverse Nous allons utiliser un reverse proxy géré par votre serveur web. Mais c'est quoi donc ? C'est simple, le proxy va recevoir toutes les requêtes (les URL tapées par les visiteurs) et va les transmettre à un serveur web selon certaines règles. Pour comprendre les exemples, il faut partir du principe que les connexions reçues par le proxy ne contiennent plus le nom de domaine. C'est à dire, pour NGINX www.monsite.com/maPage sera vu comme /maPage . Voilà un exemple pour NGINX . Il faut rajouter ces directives dans un fichier de configuration dans /etc/nginx/site-available/ , dans un bloc server : location / { proxy_pass http :// localhost : 12345 / ; } Ainsi, toutes les requêtes commençant par / (c'est à dire toutes) seront renvoyées au port 12345 (ce qui est intéressant si vous utilisez des sous domaines par exemple). Dans le cas où vous voulez transférer les connexions sur /monapp vers le port 12345 , vous devrez avoir une règle dans le genre : location / monapp / { proxy_pass http :// 127 . 0 . 0 . 1 : 12345 / ; } Dans ce cas, une URL vers monip/monapp/page1 sera transmise vers 127.0.01:12345/page1 (avec 127.0.0.1, le localhost du serveur). Attention, n'oubliez pas le / final, il permet d'éliminer le /monapp de l' URL . Grâce à lui votre application écoutant sur le port 12345 pourra analyser ses URL à partir de la racine comme si rien ne s'était passé. Les variables spéciales Comme on le voit sur le schéma, le proxy est situé sur votre réseau et va transmettre les requêtes, ce qui modifier les headers HTTP . Du coup, vous ne pouvez plus savoir quelle est l' IP de votre visiteur par exemple, vu qu'elle sera remplacée par celle indiquée dans le proxy_pass (le plus souvent 127.0.0.1). Dans ce cas, vous pouvez rajouter des variables qui permettent de remodifier le header. location /monapp/ { ... proxy_set_header Host $ host ; proxy_set_header X-Real-IP $ remote_addr ; proxy_set_header X-Forwarded-For $ proxy_add_x_forwarded_for ; ... } Conclusion L'exemple complet : location / monapp / { proxy_pass http :// 127 . 0 . 0 . 1 : 12345 / ; proxy_set_header Host $ host ; proxy_set_header X - Real - IP $ remote_addr ; proxy_set_header X - Forwarded - For $ proxy_add_x_forwarded_for ; } Finalement, il est assez aisé de faire fonctionner plusieurs services web sur son serveur en utilisant NGINX . De plus, la configuration est assez aisé, 10 lignes à rajouter dans un fichier au maximum. Il ne faut donc pas se laisser dépasser par la complexité relative de NGINX , ou d'un serveur web en général (il y a des centaines de directives et de variables). Il faut juste y aller petit à petit et se concentrer sur une configuration à la fois. Pour aller plus loin nous pouvons servir des contenus statiques avec location un tutoriel pour débutants (en anglais) pour en savoir plus sur les variables du proxy_set_header des explications plus poussées sur le proxy inverse de NGINX","tags":"Admin Sys","title":"Comment avoir plusieurs services web sur son serveur ?"},{"url":"http://true.falce.net/decouverte-de-la-gopro-hero-4.html","text":"L'histoire Je suis allé à l' OVH Summit 2015 à Paris. C'était bien sympa, bien que je ne pense pas être la cible de l'événement avec mes 30€ de dépenses par an… Une des choses qui a rendu l'événement sympa c'est les tirages au sort et tombolas, organisés par Cisco, Intel et d'autres boites que je ne connais pas. J'ai joué. Et j'ai gagné \\o/ Une GoPro. Double yeah \\o/ \\o/ Il y avait même un accessoire pour faire des selfies. Donc voilà un retour après 1 jour d'utilisation. Ma vie Je ne pense pas être clairement la cible de GoPro, je ne fais pas de saut en wingsuit ou de plongé extrême. Le sport le plus extrême que j'ai pratiqué c'est soit le tir à l'arc, soit le yoga. Du coup, je me demande bien ce que je peux filmer :) Je fais partie des personnes qui n'ont jamais touché de GoPro. Je sais que ça existe, l'on peut faire des pubs pour rebbull qui passent au cinéma avec (du coup, ça doit être plutôt correct niveau qualité) mais c'est tout. Par contre, je fais de la photo. J'ai un reflex (un vieux D90) du coup, je deviens assez exigeant sur la vitesse et la qualité des photos. Et je n'ai jamais eu de caméscope, je ne suis donc pas trop habitué à manipuler des fichiers vidéos. Du coup, plutôt que tout revendre, autant tester et voir le potentiel de la chose. Déballage L'emballage est plutôt qualitatif. La boite est en 2 parties, une transparente qui permet de voir la caméra et une avec les instructions, câbles et tout le tralala. A l'ouverture la GoPro est dans sa coque de protection. On a donc affaire à son système de fixation, à base de vis, qui sert à attacher la caméra à presque tout. Au début j'ai rien compris, j'ai galéré mais on s'y fait et c'est bien conçu. C'est facile à attacher et détacher et ça à l'air de bien tenir. 2 attaches à scotch sont fournies, pour les casques. Une fois que l'on a réussit à la défaire, ce qui choque, c'est la taille de la caméra. Avec la coque elle n'est pas très grosse (une grosse boite d'allumettes), mais nue, elle est franchement petite et légère. Plutôt impressionnant pour un truc qui monte à 12M de pixels et filme 4K. La boite contient donc la GoPro, une housse avec 3 \"portes arrières\", selon que l'on veut nager très profond (40m), pas trop profond (3m) ou rester sur terre (en gros). L'écran de la caméra est tactile et seule la porte étanche jusqu'à 40m ne permet pas de l'utiliser. Je met en charge la batterie et je feuillète le manuel. La batterie est pleine, super, on peut commencer. Ah beh non, on peut rien faire sans carte µ SD et elle n'est pas fournie :( Il y a 2 écrans : devant, en noir et blanc et d'environ 10 pixels (un peu plus) qui doit être hérité des anciennes GoPro. Il permet de faire les réglages et de voir les infos basiques (la batterie et le nombre de photos / temps de vidéo restant) derrière en couleur, tactile, qui permet de voir les photos et de faire les réglages Il y a 3 boutons : un pour prendre des photos, lancer la vidéo un pour allumer / éteindre et ils permettent de naviguer dans les menus (pour quand on n'utilise pas le tactile) L'utilisation Le manuel parle d'une application GoPro à installer sur son smartphone pour mettre à jour le firmware de la caméra. J'ai peur mais j'essaie. L'appairage se fait facilement (la GoPro crée un hotspot et l'application s'y connecte automatiquement), et la mise à jour se passe tranquillement (10 min, et ça n'a même pas planté). L'appli est agréable à utiliser, on peut également régler les différents L'application permet d'avoir une idée de ce que voit la caméra, j'imagine que c'est utile pour savoir ce qu'elle filme quand on l'a sur son casque. Sinon, c'est pas vraiment utilisable, il y a environ 2 sec de latence. Mais c'est sympa En parlant de latence, il n'y en a pas dans les menus, mais je trouve qu'il y en un petit peu pour les déclenchements de prises de vue (l'habitude du reflex). Si vous avez l'habitude d'un compact ou d'un téléphone et que ça ne gène pas, ça devrait aller. Niveau cadence, on peut filmer en 240 fps (en basse définition) ça rend bien pour les moments qui bougent ou pour les ralentis et on peut faire des rafales photos à 30 images par seconde. Niveau technique c'est simple mais plutôt réussit. L'objectif est un grand angle, ce qui a des avantages (on voit plein de choses, les déformations) et des inconvénients (les déformations, tout ce qui est à plus de 4m sera minuscule). Oui, les déformations sont un avantage et un inconvénient :) En mode film, on peut avoir un champ de vision plus étroit, je pense que la caméra ne prend que les pixels centraux du capteur (on n'a plus accès à la 4K). On ne peut pas régler l'exposition, mais on peut faire une mesure spot, qui adapte l'expo en fonction de la luminosité du centre de l'image. Et on peut sous / sur exposer. On peut régler les iso max à utiliser et la netteté. On a aussi accès à des modes sympas comme le time lapse (en photo et vidéo), on peut régler l'intervalomètre dans des valeurs définies (1 image toutes les 1-5-10-30 secondes). En vidéo, j'ai testé un couché de soleil et ça rend pas mal, un peu surexposé au début (le soleil n'étant pas au centre), mais il n'y a pas de scintillements, l'expo se refait au poil à chaque fois. Avis Pas étonnant que la GoPro soit un succès. La construction semble solide, l'interface est bien foutue, conçue pour être utilisée avec des gants, sous l'eau, donc sur terre et à main nue elle est agréable. La qualité d'image est au rendez-vous, clairement au dessus d'un téléphone, mais clairement en dessous d'un reflex, je dirai que l'on est au niveau d'un bon compact. Il ne faut pas oublier que la caméra est prévue pour faire des vidéos et que je n'ai surtout testé que la photo. Le grand angle est vraiment intéressant pour les vidéos d'action, histoire de se croire à la place du \"héro\". La petite taille permet de la transporter facilement, en attirant moins l'attention qu'un gros reflex. Ce qui peut s'avérer utile en voyage, même sans faire de saut en parachute ;) Mais par contre, les vidéos que l'on voit sont toutes filmées en plein jour. Ça ne m'étonnes pas, les résultats que j'ai eu en photo de nuit, se sont avérés assez décevant, beaucoup de flou ou photo mal exposé, je ne sais pas trop ce que ça donne en vidéo la nuit. Les seuls vrais reproche que je ferrai pour l'instant sont sur la batterie, l'alimentation et la chaleur dégagée. Un cable µ USB (ceux des téléphones) aurait été plus judicieux à mon avis. La durée de vie me semble courte (dans les 4-5h d'utilisation), bon, je pense que je n'ai pas encore tout compris sur la gestion de la batterie (couper l'écran par exemple). De plus, la caméra se met à chauffer assez vite assez fort (elle était dans un sac), rien de méchant heureusement, mais je me demande si ça ne peut pas abimer la coque à force. Du coup, je vais la garder et m'en servir pour faire tout ce que je n'ose pas faire avec mon réflex (sous l'eau, au ski…). D'un point de vue plus artistique, je pense qu'il y a moyen de faire des trucs sympas avec le grand angle et les modes timelapses. Il y aura surement un autre retour, quand j'aurai une meilleure connaissance des performances de la chose. Stay tuned .","tags":"Revue","title":"Découverte de la GoPro Hero 4"},{"url":"http://true.falce.net/bonjour-le-monde.html","text":"Salut Le tout premier article, de mon tout premier blog. Espérons qu'il y en aura beaucoup d'autres dans le futur :) Je pense que la plupart des articles sera en français. Pourquoi ? 2 raisons. D'une je n'écrit pas souvent, autant que ça soit dans ma langue maternelle, et puis, la subtilité, les jeux de mots, ça n'a pas de prix. Et surtout, on peut surement trouver les mêmes choses en anglais, mais pas forcément en français, alors autant servir à dynamiser une communauté… On parlera d'un peu de tout, en particulier : de choses geeks de choses techniques de sciences (surtout de la bio-info) Et comme j'aime bien râler, il y aura aussi des coups de gueule. A bientôt.","tags":"Autre","title":"Bonjour le monde"}]}